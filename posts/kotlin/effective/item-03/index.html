<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.101.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>item03 최대한 플랫폼 타입을 사용하지 말라&nbsp;&ndash;&nbsp;Ors</title><link rel="stylesheet" href="/css/core.min.9e958365cf0319ede466a402e1369f31dc1f205c868aa836fe25581725c829d3f3545d9f142cccafe35363950a63e2a6.css" integrity="sha384-npWDZc8DGe3kZqQC4TafMdwfIFyGiqg2/iVYFyXIKdPzVF2fFCzMr&#43;NTY5UKY&#43;Km"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="item03 최대한 플랫폼 타입을 사용하지 말라" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">Ors</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">item03 최대한 플랫폼 타입을 사용하지 말라</h1><p class="article date">Saturday, August 6, 2022<span class="reading-time"> • 3 minutes to read</span></p></section><article class="article markdown-body"><p>코틀린의 주요 기능 중 하나는 null-safe 입니다.
자바에서 자주 볼 수 있었던 NPE 는 코틀린에서 null-safety 메커니즘으로 인해 거의 찾아보기 힘듭니다.
다만, 자바나 C 등의 프로그래밍 언어와 코틀린을 연결해서 사용할 때는 이러한 예외가 발생 할 수 있습니다.</p>
<p>만약 Java 에서 String 을 리턴하는 메서드가 있을 경우, 코틀린에서 이를 어떻게 처리해야할까요 ?</p>
<ul>
<li>String? =&gt; Nullable annotation 이 있을 경우</li>
<li>String =&gt; Nonnull annotation 이 있을 경우</li>
</ul>
<p>만약 다음과 같이 annotation 이 붙어 있지 않다면, 어떻게 처리해야할까요 ?</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JavaTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">public</span> <span class="n">String</span> <span class="nf">giveName</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>자바에서는 모든 것이 Nullable 이므로, 최대한 안전하게 다루기 위해서는 nullable 로 가정하고 다뤄야합니다.
하지만, null 이 아님이 확신 가능한 경우 non-null 단정을 나타내는 !! 을 붙여 회피할 수 있습니다.</p>
<blockquote>
<p>실제 코드를 보면 !! 을 많이 볼 수 있습니다.</p>
</blockquote>
<p>nullable 과 관련하여 자주 문제가 되는 부분은 자바의 제네릭타입 입니다.
자바 API 에서 <code>List&lt;User&gt;</code>를 리턴하고, annotation 이 따로 붙어 있지 않은 경우 코틀린이 디폴트로 모든 타입을 nullable로 다룬다면 어떤일이 발생할까요?</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nf">UserRepo</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="nf">getUser</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><blockquote>
<p>kotlin</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">val</span> <span class="py">users</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">UserRepo</span><span class="p">().</span><span class="n">user</span><span class="o">!!</span><span class="p">.</span><span class="n">filterNotNull</span><span class="p">()</span>
</span></span></code></pre></div><p>List 뿐 아니라, 내부 Item 들에 대해서도 null check 를 진행해야합니다. 더 나아가서 Collection들이 중첩으로 사용 될 경우, 코드는 더 복잡하게 변합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">val</span> <span class="py">user</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;&gt;</span> <span class="p">=</span> <span class="n">UserRepo</span><span class="p">().</span><span class="n">groupedUsers</span><span class="o">!!</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="k">it</span><span class="o">!!</span><span class="p">.</span><span class="n">filterNotNull</span><span class="p">()</span> <span class="p">}</span>
</span></span></code></pre></div><p>이러한 문제를 피하고자, 코틀린에서는 다른 프로그래밍 언어에서 넘어온 타입들을 <code>플랫폼 타입</code>으로 특수하게 다룹니다.</p>
<p><code>플랫폼 타입</code>은 타입 으름 뒤에 <code>!</code> 기호를 붙여서 표기합니다.</p>
<blockquote>
<p>플랫폼 타입이란 nullable 인지 아닌지 알 수 없는 타입을 의미하며, 직접적으로 코드에 나타나지 않습니다.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">val</span> <span class="py">repo</span> <span class="p">=</span> <span class="n">UserRepo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="py">user1</span> <span class="p">=</span> <span class="n">repo</span><span class="p">.</span><span class="n">user</span> <span class="c1">// 타입은 User!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="py">user2</span><span class="p">:</span> <span class="n">User</span> <span class="p">=</span> <span class="n">repo</span><span class="p">.</span><span class="n">user</span> <span class="c1">// Nonnull
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="py">user3</span><span class="p">:</span> <span class="n">User</span><span class="p">?</span> <span class="p">=</span> <span class="n">repo</span><span class="p">.</span><span class="n">user</span> <span class="c1">// Nullable
</span></span></span></code></pre></div><p>위처럼 코드를 사용할 수 있으므로, 이전에 언급했던 문제는 사라집니다.
다만, null 이 아니라고 표현했던 타입이 null 일 가능성이 있으므로 여전히 위험한 부분이 존재합니다.</p>
<p>따라서 함수가 지금 당장 null을 리턴하지 않더라도, 미래에 변경될 수 있다는것을 염두해둬야하며 주석 혹은 annotation등을 이용해 이를 표시해두어야합니다.</p>
<blockquote>
<p>자바를 코틀린과 함께 사용할 때, 자바 코드를 직접 조작할 수 있다면 annotation을 사용하여 이를 방지해야합니다.</p>
</blockquote>
<p>지원하는 annotation 은 <a href="https://kotlinlang.org/docs/java-interop.html#nullability-annotations"target="_blank" rel="noopener noreferrer">다음</a>
과 같습니다.</p>
<h3 id="platformtype-을-제거해야하는-이유">PlatformType 을 제거해야하는 이유</h3>
<p>이와 같은 플랫폼 타입은 안전하지 않으므로 최대한 빨리 제거해야합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JavaClass</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">public</span> <span class="n">String</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">fun</span> <span class="nf">statedType</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">val</span> <span class="py">value</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="n">JavaClass</span><span class="p">().</span><span class="k">value</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">print</span><span class="p">(</span><span class="k">value</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">val</span> <span class="py">value</span> <span class="p">=</span> <span class="n">JavaClass</span><span class="p">().</span><span class="k">value</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">println</span><span class="p">(</span><span class="k">value</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>두가지 경우 모두 NPE 가 발생하지만, 오류의 발생 위치에 차이가 있습니다.</p>
<p><code>(1)</code>은 값을 가져오는 부분에서 NPE 가 발생합니다. 따라서 코드를 굉장히 쉽게 수정할 수 있습니다.
다만, <code>(2)</code>는 실제 값을 사용할때 NPE 가 발생하게 됩니다. 선언 시점과 사용 시점이 차이가 날 경우 원인을 파악하는데 오랜 시간이 소요될 수 있습니다.</p>
<p>이러한 플랫폼 타입은 더 많은 위험 가능성을 갖고 있는데, interface + inferred 타입 (추론된 타입) 이 사용 될 경우, 더 큰 혼란을 야기할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">interface</span> <span class="nc">UserRepo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">fun</span> <span class="nf">getUserName</span><span class="p">()</span> <span class="p">=</span> <span class="n">javaClass</span><span class="p">().</span><span class="k">value</span> <span class="c1">// inferred (platformType)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RepoImpl</span> <span class="p">:</span> <span class="n">UserRepo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">override</span> <span class="k">fun</span> <span class="nf">getUserName</span><span class="p">():</span> <span class="n">String</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RepoImpl2</span> <span class="p">:</span> <span class="n">UserRepo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">override</span> <span class="k">fun</span> <span class="nf">getUserName</span><span class="p">():</span> <span class="n">String</span><span class="p">?</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>위처럼 상속 받은 하위 클래스에서 nullable 여부를 지정할수 있기때문에, 실제 설계와는 다른 혼란을 발생시킬 수 있습니다.</p>
<h3 id="결론">결론</h3>
<p>이러한 예시들처럼 플랫폼 타입이 전파되는 일은 굉장히 위험합니다.
따라서, 안전한 코드를 원한다면 이러한 부분을 제거하는 것이 좋습니다.</p>
</article><section class="article labels"><a class="category" href=/categories/kotlin/>kotlin</a><a class="tag" href=/tags/kotlin/>kotlin</a><a class="tag" href=/tags/effective/>effective</a></section>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/posts/kotlin/effective/item-04/"><span class="iconfont icon-article"></span>item04 inferred 타입으로 리턴하지 말라</a></p><p><a class="link" href="/posts/kotlin/effective/item-02/"><span class="iconfont icon-article"></span>item02 변수의 스코프를 최소화하라</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2019 Notepadium.</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div>
</section></body>

</html>