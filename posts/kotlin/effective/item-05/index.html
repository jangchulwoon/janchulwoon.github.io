<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.101.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>item05 예외를 활용해 코드에 제한을 걸어라&nbsp;&ndash;&nbsp;Ors</title><link rel="stylesheet" href="/css/core.min.9e958365cf0319ede466a402e1369f31dc1f205c868aa836fe25581725c829d3f3545d9f142cccafe35363950a63e2a6.css" integrity="sha384-npWDZc8DGe3kZqQC4TafMdwfIFyGiqg2/iVYFyXIKdPzVF2fFCzMr&#43;NTY5UKY&#43;Km"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="item05 예외를 활용해 코드에 제한을 걸어라" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">Ors</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">item05 예외를 활용해 코드에 제한을 걸어라</h1><p class="article date">Tuesday, August 9, 2022<span class="reading-time"> • 4 minutes to read</span></p></section><article class="article markdown-body"><p>확실하게 어떤 형태로 동작해야하는 코드가 있다면, 예외를 활용해 제한을 걸어주는 것이 좋습니다.
Kotlin 에서는 다음과 같은 방법을 사용 할 수 있습니다.</p>
<ul>
<li><code>require</code> : argument 를 제한 할 수 있습니다.</li>
<li><code>check</code> : 상태와 관련된 동작을 제한 할 수 있습니다.</li>
<li><code>assert</code> : 어떤 것이 true 인지 확인합니다. (test 모드에서만 작동)</li>
</ul>
<p>예시 )</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">fun</span> <span class="nf">pop</span><span class="p">(</span><span class="n">num</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">1</span><span class="p">):</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">require</span><span class="p">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;cannot remove more elements than current size&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">check</span><span class="p">(</span><span class="n">isOpen</span><span class="p">)</span> <span class="p">{</span> <span class="s2">&#34;cannot pop from closed stack&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="py">ret</span> <span class="p">=</span> <span class="n">collection</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">collection</span> <span class="p">=</span> <span class="n">collection</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">ret</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ret</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>이렇게 제한을 걸어 주면 다양한 장점이 발생합니다.</p>
<ul>
<li>문서를 읽지 않은 개발자도 문제를 확인 할 수 있습니다.</li>
<li>문제가 있을 경우, 예외를 리턴합니다. 예상하지 못한 동작을 막을 수 있습니다.</li>
<li>코드가 어느 정도 자체적으로 검사되며 관련된 단위 테스트를 줄일 수 있습니다.</li>
<li><code>스마트 캐스트</code> 기능을 활용 할 수 있게 되므로, cast를 적게 할 수 있습니다.</li>
</ul>
<h3 id="argument-require">argument (require)</h3>
<p>함수를 정의할 때, argument 에 제한을 거는 코드를 많이 사용합니다.</p>
<blockquote>
<p>null / size / valid 검사등 argument 를 검사하는 경우는 많습니다.</p>
</blockquote>
<p>일반적으로 이러한 제한을 걸때, require 함수를 사용합니다.
<code>require</code> 는 제한을 확인 하고, 만족하지 못할 경우 예외를 던집니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">fun</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Long</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">require</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="m">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="m">1</span><span class="p">)</span> <span class="k">else</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">*</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">fun</span> <span class="nf">findCluster</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Point</span><span class="p">&gt;):</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Cluster</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">require</span><span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">isNotEmpty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">fun</span> <span class="nf">sendEmail</span><span class="p">(</span><span class="n">user</span><span class="p">:</span> <span class="n">User</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">requireNotNull</span><span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="n">email</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>이와 같은 형태의 입력 유효성 검사 코드는 함수의 가장 앞부분에 배치되므로, 읽는 사람도 쉽게 확인 할 수 있습니다.
require 함수는 조건을 만족하지 못할 때, 무조건 적으로 IllegalArgumentException 을 발생 시키므로, 제한을 무시할 수 없습니다.</p>
<blockquote>
<p>만약 공개된 API라면 이러한 제한 조건들을 문서에 기록해두어야합니다.</p>
</blockquote>
<p>또한 다음과 같은 방법으로 람다를 활용하여 지연 메시지를 정의할 수 도 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="n">require</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span> <span class="s2">&#34;cannot calculate factorial of </span><span class="si">$n</span><span class="s2"> ~&#34;</span> <span class="p">}</span>
</span></span></code></pre></div><h3 id="상태">상태</h3>
<p>어떤 구체적인 조건을 만족할 때만 함수를 사용 할 수 있게 해야 할 때가 있습니다.</p>
<ul>
<li>초기화 되어 있어야만 처리를 하게 하고 싶은 경우</li>
<li>사용자가 로그인 했을때만 처리를 하고 싶은 경우</li>
<li>객체를 사용할 수 있는 시점에 사용하고 싶은 경우</li>
</ul>
<p>상태와 관련된 제한을 걸때는 일반적으로 check 함수를 사용합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">fun</span> <span class="nf">speak</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">check</span><span class="p">(</span><span class="n">isInitialized</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">fun</span> <span class="nf">getUser</span><span class="p">():</span> <span class="n">User</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">checkNotNull</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>check 함수는 require와 비슷하지만 지정된 예측을 만족하지 못할 때, IllegalStatException을 throw 합니다.</p>
<blockquote>
<p>상태가 올바른지 확인할 때 사용하며, 함수 전체에 대한 어떤 예측이 잇을때는 일반적으로 require 블록 뒤에 배치합니다.</p>
</blockquote>
<p>이러한 확인은 사용자가 규약을 어기고, 사용하면 안되는 곳에서 함수를 호출하고 있다고 의심될 때 합니다.</p>
<h3 id="assert-계열-함수">Assert 계열 함수</h3>
<p>함수가 올바르게 구현되었다면, 확실하게 참을 낼 수 있는 코드들이 있습니다.
이러한 구현 문제로 발생할 수 있는 추가적인 문제를 예방하려면, 단위 테스트를 사용하는 것이 좋습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StackTest</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">  <span class="k">fun</span> <span class="nf">`스택은 정확한 수의 element 를 반환한다.`</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="py">stack</span> <span class="p">=</span> <span class="n">Stack</span><span class="p">(</span><span class="m">20</span><span class="p">)</span> <span class="p">{</span> <span class="k">it</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="py">ret</span> <span class="p">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">assertEquals</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="n">ret</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>단위 테스트만으로 확인하기 어려운 경우, 호출 위치에서 제대로 동작하는지 확인 할 수 있습니다.
다음과 같이 함수 내부에서 assert 계열의 함수를 사용하여, 내부 구현에서 검증을 할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">fun</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">ret</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>이러한 조건은 -ea JVM 옵션을 활성해야 확인할 수 있습니다.
application 환경에선 throw 를 발생하지 않으며, test 환경에서만 동작하는 블록입니다.</p>
<blockquote>
<p>만약 심각한 오류일 경우엔 assert 보단 check 를 이용해 예외를 반환하는게 좋습니다.</p>
</blockquote>
<p>assert block 의 장점은 실제 코드가 더 빠른 시점에 실패하게 만드는 것입니다.
따라서, 예상하지 못한 동작이 언제 어디서 실행되었는지 쉽게 찾을 수 있습니다.</p>
<blockquote>
<p>코드를 안정적으로 만들고 싶을 때, 양념처럼 사용할 수 있다는 것을 기억하세요.</p>
</blockquote>
<h3 id="nullability-와-스마트-캐스팅">Nullability 와 스마트 캐스팅</h3>
<p>코틀린에서 require / check 블록으로 어떤 조건을 확인해서 true 가 나왔다면, 해당 조건은 이후로도 true 일거라 가정합니다.
따라서, 이를 활용하여 타입 비교를 했다면, <code>smart cast</code> 가 작동합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">fun</span> <span class="nf">changeDress</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="n">Person</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">require</span><span class="p">(</span><span class="n">person</span><span class="p">.</span><span class="n">outfit</span> <span class="k">is</span> <span class="n">Dress</span><span class="p">)</span>  <span class="c1">// final 이라면 smartCast !
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">val</span> <span class="py">dress</span><span class="p">:</span> <span class="n">Dress</span> <span class="p">=</span> <span class="n">person</span><span class="p">.</span><span class="n">outfit</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>이러한 smartCast 는 null 인지 확인할 때 굉장히 유용합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">fun</span> <span class="nf">valid</span><span class="p">(</span><span class="k">value</span><span class="p">:</span> <span class="n">Value</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">require</span><span class="p">(</span><span class="n">obj</span> <span class="o">!=</span> <span class="k">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="py">value</span> <span class="p">=</span> <span class="n">requireNotNull</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="k">value</span><span class="p">)</span> <span class="c1">// 변수를 Unpack 하는 용도로도 사용 할 수 있습니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">valid</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="k">value</span><span class="p">)</span>
</span></span></code></pre></div><p>나아가 Elvis 연산을 이용하여 null 일 경우 return / throw 를 할 수도 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">val</span> <span class="py">value</span> <span class="p">=</span> <span class="n">obj</span><span class="p">.</span><span class="k">value</span> <span class="o">?:</span> <span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="py">value</span> <span class="p">=</span> <span class="n">obj</span><span class="p">.</span><span class="k">value</span> <span class="o">?:</span> <span class="k">throw</span> <span class="n">Exception</span><span class="p">()</span>
</span></span></code></pre></div><p>만약 null 처리와 함께 로그를 남겨야한다면, <code>run</code> 함수를 이용할 수 도 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">val</span> <span class="py">value</span> <span class="p">=</span> <span class="n">obj</span><span class="p">.</span><span class="k">value</span> <span class="o">?:</span> <span class="n">run</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">log</span><span class="p">(</span><span class="s2">&#34;value is null&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>이처럼 return 과 throw 를 활용한 Elvis 연산은 nullable을 확인할 때 굉장히 많이 사용되는 관용적인 방법입니다.
적극적으로 활용하는 것이 좋으며, 함수 앞부분에 넣어 잘 보이게 만드는 것이 좋습니다.</p>
</article><section class="article labels"><a class="category" href=/categories/kotlin/>kotlin</a><a class="tag" href=/tags/kotlin/>kotlin</a><a class="tag" href=/tags/effective/>effective</a></section>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/posts/kotlin/effective/item-06/"><span class="iconfont icon-article"></span>item06 사용자 정의 오류보다는 표준 오류를 사용하라.</a></p><p><a class="link" href="/posts/kotlin/effective/item-04/"><span class="iconfont icon-article"></span>item04 inferred 타입으로 리턴하지 말라</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2019 Notepadium.</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div>
</section></body>

</html>