<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.88.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>RestTemplate Request / Response Logging&nbsp;&ndash;&nbsp;Sketchbook</title><link rel="stylesheet" href="/css/core.min.0c1ef03bca587fb8fb2c1073f3c6462e16d7ee1d0152e887ab07bda1c16f6a4214f31b0443773aaf34e5228c2ccc8c8c.css" integrity="sha384-DB7wO8pYf7j7LBBz88ZGLhbX7h0BUuiHqwe9ocFvakIU8xsEQ3c6rzTlIowszIyM"><body>
    <div class="base-body"><section id="header" class="site header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">Sketchbook</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about/">About</a><a class="nav item" href="/">Sketchbook</a></nav></div></span></div><div class="site slogan"><span class="title">빈 스케치북에 뭐라도 적어놔야지</span></div></section><div id="content"><section class="article header">
    <h1 class="article title">RestTemplate Request / Response Logging</h1><p class="article date">Sep 15, 2021</p></section><article class="article markdown-body"><p>QA 및 개발 환경에서 외부 API에 대한 요청/응답을 로깅해야하는 상황이 자주 발생합니다. 이 글에선 RestTemplate 을 Logging 하기위한 설정을 다룹니다.</p>
<blockquote>
<p>Log 크기에 따라 real 환경에선 사용을 피하는 편이 좋습니다.</p>
</blockquote>
<h2 id="설정-요약">설정 요약</h2>
<blockquote>
<p>interceptor</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="k">class</span> <span class="nc">HttpResponseLoggingInterceptor</span> <span class="p">:</span> <span class="n">ClientHttpRequestInterceptor</span> <span class="p">{</span>
    <span class="k">companion</span> <span class="k">object</span> <span class="p">{</span>
        <span class="k">val</span> <span class="py">log</span> <span class="p">=</span> <span class="n">LoggerFactory</span><span class="p">.</span><span class="n">getLogger</span><span class="p">(</span><span class="k">this</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">intercept</span><span class="p">(</span><span class="n">request</span><span class="p">:</span> <span class="n">HttpRequest</span><span class="p">,</span> <span class="n">body</span><span class="p">:</span> <span class="n">ByteArray</span><span class="p">,</span> <span class="n">execution</span><span class="p">:</span> <span class="n">ClientHttpRequestExecution</span><span class="p">):</span> <span class="n">ClientHttpResponse</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">body</span><span class="p">.</span><span class="n">isNotEmpty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;reqeustBody : </span><span class="si">$body</span><span class="s2">&#34;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">val</span> <span class="py">response</span> <span class="p">=</span> <span class="n">execution</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>

        <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;response Header : </span><span class="si">${response.headers}</span><span class="s2">&#34;</span><span class="p">)</span>
        <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;response body : </span><span class="si">${IOUtils.toString(response.body, UTF_8)}</span><span class="s2">&#34;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">response</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>restConfig</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="nd">@Configuration</span>
<span class="k">open</span> <span class="k">class</span> <span class="nc">GitBlogRestTemplateConfig</span> <span class="p">{</span>

    <span class="nd">@Bean</span>
    <span class="k">open</span> <span class="k">fun</span> <span class="nf">gitBlogRestTemplate</span><span class="p">(</span><span class="n">restTemplateBuilder</span><span class="p">:</span> <span class="n">RestTemplateBuilder</span><span class="p">):</span> <span class="n">RestTemplate</span> <span class="p">=</span> <span class="n">restTemplateBuilder</span>
            <span class="p">.</span><span class="n">requestFactory</span> <span class="p">{</span> <span class="n">BufferingClientHttpRequestFactory</span><span class="p">(</span><span class="n">SimpleClientHttpRequestFactory</span><span class="p">())</span> <span class="p">}</span>
            <span class="p">.</span><span class="n">additionalInterceptors</span><span class="p">(</span><span class="n">listOf</span><span class="p">(</span><span class="n">HttpResponseLoggingInterceptor</span><span class="p">()))</span>
            <span class="p">.</span><span class="n">build</span><span class="p">()</span>

<span class="p">}</span>
</code></pre></div><h2 id="io-stream-">IO Stream ??</h2>
<p>Stream이란 운영체제에 의해 생성되는 가상의 통로로, 프로그램과 I/O 사이의 중간 매개자 역할을 수행합니다. Stream 은 단방향으로만 통신이 가능하다는 특성을 갖고 있는데요. 때문에 Java 에서는 java.io package 안에 InputStream 과 OutputStream을 각각 제공하고 있습니다.</p>
<blockquote>
<p>InputStrema 과 OutputStream 은 추상 클래스로, 일부 함수를 재정의해야합니다.</p>
</blockquote>
<p>앞서 말했듯, Stream 은 가상의 통로로, 별다른 설정을 하지 않는다면 한번 소비된 byte를 다시 읽어 올 수 없습니다.</p>
<blockquote>
<p>mark / reset 등의 함수를 이용하여, 원하는 지점부터 다시 읽을 수 있으나, 추가 구현이 필요하며, 데이터를 memory에 저장하여 관리해야한다.</p>
</blockquote>
<p>이러한 특성으로, RestTemplate 의 request / response 를 logging 하기위해선 <code>별도의 설정</code> 이 필요하다.</p>
<h2 id="clienthttprequestfactory-">ClientHttpRequestFactory ??</h2>
<p>ClientHttpRequestFactory는 Connect / Socket timeout 및 connectionPool 등의 설정을 지원하며, ClientHttpRequest를 생성하는 factory class 이다.
개인적으로 혼란스러웠던 부분은, <code>RequestFactory 가 Response Logging 에 무슨 영향이 있지?</code> 인데, ClientHttpRequest가 execute 함수를 제공하며, response 를 리턴하기 때문에, 이를 생성하는 Factory 구현에 영향을 받는다.</p>
<blockquote>
<p>BufferingClientHttpRequestFactory 주석에도 이 내용이 적혀있다.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BufferingClientHttpRequestFactory</span>
<span class="kd">extends</span> <span class="n">AbstractClientHttpRequestFactoryWrapper</span>
<span class="n">Wrapper</span> <span class="k">for</span> <span class="n">a</span> <span class="n">ClientHttpRequestFactory</span> <span class="n">that</span> <span class="n">buffers</span> <span class="n">all</span> <span class="n">outgoing</span> <span class="n">and</span> <span class="n">incoming</span> <span class="n">streams</span> <span class="n">in</span> <span class="n">memory</span><span class="o">.</span>
<span class="n">Using</span> <span class="k">this</span> <span class="n">wrapper</span> <span class="n">allows</span> <span class="k">for</span> <span class="n">multiple</span> <span class="n">reads</span> <span class="n">of</span> <span class="n">the</span> <span class="n">response</span> <span class="n">body</span><span class="o">.</span>
</code></pre></div><p>RestTemplate의 getBody함수는 InputStream 을 통해 결과를 읽어오는데, 앞서 말했듯 Stream 은 한번 소비되고 다시 읽을 수 없다.
때문에 interceptor를 이용해 body를 logging을 하게되면, 실제 response 를 가져올땐 body가 빈 상태로 서비스 코드에 전달된다.</p>
<p>이를 막기위해 <code>BufferingClientHttpRequestFactory</code> 를 설정해줘야한다.</p>
<p><code>주의</code></p>
<p>BufferingClientHttpRequestFactory를 타고 가다보면, Response 를 BufferingClientHttpResponseWrapper로 감쌓는걸 볼 수 있다.
해당 클래스는 body 값을 property로 들고 있어, 응답이 클 경우 메모리 관리에 영향을 주게 된다.
특별한 이유가 아니라면, real 상황에서는 사용을 자제해야한다.</p>
</article><section class="article labels"><a class="category" href=/categories/kotlin/>Kotlin</a><a class="category" href=/categories/spring/>Spring</a><a class="tag" href=/tags/resttemplate/>RestTemplate</a></section><section class="article navigation"><p><a class="link" href="/posts/linux-command-tricks/"><span class="li">&rarr;</span>Linux Command Tips And Tricks</a class="link">
    </p></section></div><section id="footer" class="footer"><div class="footer-wrap">
    <p class="copyright">©2020 Notepadium.</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section></div>
</body>

</html>